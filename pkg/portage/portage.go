// Package portage handles Portage configuration and make.conf generation.
package portage

import (
	"fmt"
	"path/filepath"
	"runtime"
	"strings"

	"github.com/japaneseenrichmentorganization/yuno_os/pkg/config"
	"github.com/japaneseenrichmentorganization/yuno_os/pkg/utils"
)

// Manager handles Portage configuration.
type Manager struct {
	config    *config.InstallConfig
	targetDir string
}

// NewManager creates a new Portage configuration manager.
func NewManager(cfg *config.InstallConfig, targetDir string) *Manager {
	return &Manager{
		config:    cfg,
		targetDir: targetDir,
	}
}

// GenerateMakeConf generates the make.conf file.
func (m *Manager) GenerateMakeConf() error {
	utils.Info("Generating make.conf")

	cfg := m.config.Portage

	// Determine CFLAGS
	cflags := cfg.CFlags
	if cflags == "" {
		cflags = cfg.CFlagsPreset.GetCFlags()
	}
	if cflags == "" {
		cflags = "-march=native -O2 -pipe"
	}

	// Determine MAKEOPTS
	makeopts := cfg.MakeOpts
	if makeopts == "" {
		cores := runtime.NumCPU()
		makeopts = fmt.Sprintf("-j%d", cores)
	}

	// Build make.conf content
	var content strings.Builder

	content.WriteString("# Yuno OS make.conf - Generated by installer\n")
	content.WriteString("# See /usr/share/portage/config/make.conf.example for reference\n\n")

	// Compiler flags
	content.WriteString("# Compiler flags\n")
	content.WriteString(fmt.Sprintf("COMMON_FLAGS=\"%s\"\n", cflags))
	content.WriteString("CFLAGS=\"${COMMON_FLAGS}\"\n")
	content.WriteString("CXXFLAGS=\"${COMMON_FLAGS}\"\n")
	content.WriteString("FCFLAGS=\"${COMMON_FLAGS}\"\n")
	content.WriteString("FFLAGS=\"${COMMON_FLAGS}\"\n")

	// Rust flags if using native
	if strings.Contains(cflags, "native") {
		content.WriteString("RUSTFLAGS=\"-C target-cpu=native\"\n")
	}
	content.WriteString("\n")

	// Build parallelism
	content.WriteString("# Build parallelism\n")
	content.WriteString(fmt.Sprintf("MAKEOPTS=\"%s\"\n", makeopts))
	content.WriteString(fmt.Sprintf("EMERGE_DEFAULT_OPTS=\"--jobs=%d --load-average=%d\"\n\n",
		runtime.NumCPU()/2+1, runtime.NumCPU()))

	// USE flags
	if len(cfg.UseFlags) > 0 {
		content.WriteString("# Global USE flags\n")
		content.WriteString(fmt.Sprintf("USE=\"%s\"\n\n", strings.Join(cfg.UseFlags, " ")))
	}

	// VIDEO_CARDS
	if len(cfg.VideoCards) > 0 {
		content.WriteString("# Graphics drivers\n")
		content.WriteString(fmt.Sprintf("VIDEO_CARDS=\"%s\"\n\n", strings.Join(cfg.VideoCards, " ")))
	} else if m.config.Graphics.Driver != "" {
		videoCards := m.config.Graphics.Driver.GetVideoCards()
		if videoCards != "" {
			content.WriteString("# Graphics drivers\n")
			content.WriteString(fmt.Sprintf("VIDEO_CARDS=\"%s\"\n\n", videoCards))
		}
	}

	// INPUT_DEVICES
	inputDevices := cfg.InputDevices
	if len(inputDevices) == 0 {
		inputDevices = []string{"libinput"}
	}
	content.WriteString("# Input devices\n")
	content.WriteString(fmt.Sprintf("INPUT_DEVICES=\"%s\"\n\n", strings.Join(inputDevices, " ")))

	// Accept keywords
	if cfg.AcceptKeywords != "" {
		content.WriteString(fmt.Sprintf("ACCEPT_KEYWORDS=\"%s\"\n", cfg.AcceptKeywords))
	}

	// Accept license
	acceptLicense := cfg.AcceptLicense
	if acceptLicense == "" {
		acceptLicense = "*"
	}
	content.WriteString(fmt.Sprintf("ACCEPT_LICENSE=\"%s\"\n\n", acceptLicense))

	// Features
	features := cfg.Features
	if len(features) == 0 {
		features = []string{"parallel-fetch", "candy", "buildpkg"}
	}

	// Add binary package features if enabled
	if m.config.Packages.UseBinary != config.BinaryNone {
		features = append(features, "getbinpkg")
		if m.config.Packages.UseBinary == config.BinaryOnly {
			features = append(features, "binpkg-request-signature")
		}
	}

	content.WriteString("# Portage features\n")
	content.WriteString(fmt.Sprintf("FEATURES=\"%s\"\n\n", strings.Join(features, " ")))

	// Mirrors
	if len(cfg.Mirrors) > 0 {
		content.WriteString("# Gentoo mirrors\n")
		content.WriteString(fmt.Sprintf("GENTOO_MIRRORS=\"%s\"\n\n", strings.Join(cfg.Mirrors, " ")))
	}

	// Binary package host
	if m.config.Packages.BinaryHost != "" {
		content.WriteString("# Binary packages\n")
		content.WriteString(fmt.Sprintf("PORTAGE_BINHOST=\"%s\"\n\n", m.config.Packages.BinaryHost))
	}

	// Grub platforms
	content.WriteString("# Bootloader\n")
	if utils.IsUEFI() {
		content.WriteString("GRUB_PLATFORMS=\"efi-64\"\n")
	} else {
		content.WriteString("GRUB_PLATFORMS=\"pc\"\n")
	}
	content.WriteString("\n")

	// Language/locale settings
	content.WriteString("# Locale\n")
	lang := strings.Split(m.config.Locale, ".")[0]
	content.WriteString(fmt.Sprintf("L10N=\"%s\"\n", strings.ToLower(strings.Replace(lang, "_", "-", 1))))
	content.WriteString(fmt.Sprintf("LINGUAS=\"%s\"\n\n", strings.ToLower(strings.Split(lang, "_")[0])))

	// Extra settings
	if len(cfg.Extra) > 0 {
		content.WriteString("# Additional settings\n")
		for key, value := range cfg.Extra {
			content.WriteString(fmt.Sprintf("%s=\"%s\"\n", key, value))
		}
		content.WriteString("\n")
	}

	// Write the file
	makeConfPath := filepath.Join(m.targetDir, "etc/portage/make.conf")
	if err := utils.WriteFile(makeConfPath, content.String(), 0644); err != nil {
		return utils.NewError("portage", "failed to write make.conf", err)
	}

	return nil
}

// SetupPackageUse sets up package.use directory and files.
func (m *Manager) SetupPackageUse() error {
	utils.Info("Setting up package.use")

	useDir := filepath.Join(m.targetDir, "etc/portage/package.use")
	if err := utils.CreateDir(useDir, 0755); err != nil {
		return utils.NewError("portage", "failed to create package.use directory", err)
	}

	// Create default use flags based on desktop selection
	var desktopUse strings.Builder

	switch m.config.Desktop.Type {
	case config.DesktopKDE:
		desktopUse.WriteString("# KDE Plasma\n")
		desktopUse.WriteString("kde-plasma/* wayland\n")
		desktopUse.WriteString("kde-apps/* wayland\n")
		desktopUse.WriteString("dev-qt/* wayland\n")

	case config.DesktopGNOME:
		desktopUse.WriteString("# GNOME\n")
		desktopUse.WriteString("gnome-base/* wayland\n")
		desktopUse.WriteString("x11-libs/gtk+ wayland\n")

	case config.WMSway, config.WMHyprland:
		desktopUse.WriteString("# Wayland compositors\n")
		desktopUse.WriteString("gui-wm/* wayland\n")
		desktopUse.WriteString("gui-apps/* wayland\n")
	}

	// Add graphics-specific flags
	switch m.config.Graphics.Driver {
	case config.GPUNvidia, config.GPUNvidiaOpen:
		desktopUse.WriteString("\n# NVIDIA\n")
		desktopUse.WriteString("x11-drivers/nvidia-drivers modules kernel-open\n")
		desktopUse.WriteString("media-libs/mesa -video_cards_nouveau\n")

	case config.GPUAmdgpu:
		desktopUse.WriteString("\n# AMD\n")
		desktopUse.WriteString("media-libs/mesa vulkan\n")
		desktopUse.WriteString("x11-libs/libdrm video_cards_amdgpu\n")
	}

	if desktopUse.Len() > 0 {
		usePath := filepath.Join(useDir, "desktop")
		if err := utils.WriteFile(usePath, desktopUse.String(), 0644); err != nil {
			return utils.NewError("portage", "failed to write package.use/desktop", err)
		}
	}

	return nil
}

// SetupPackageAcceptKeywords sets up package.accept_keywords.
func (m *Manager) SetupPackageAcceptKeywords() error {
	keywordsDir := filepath.Join(m.targetDir, "etc/portage/package.accept_keywords")
	if err := utils.CreateDir(keywordsDir, 0755); err != nil {
		return utils.NewError("portage", "failed to create package.accept_keywords directory", err)
	}

	// Add common unstable packages for desktop use
	var keywords strings.Builder

	// Hyprland often needs unstable
	if m.config.Desktop.Type == config.WMHyprland {
		keywords.WriteString("# Hyprland\n")
		keywords.WriteString("gui-wm/hyprland ~amd64\n")
		keywords.WriteString("gui-libs/hyprland-protocols ~amd64\n")
		keywords.WriteString("dev-libs/hyprland-plugins ~amd64\n")
	}

	if keywords.Len() > 0 {
		keywordsPath := filepath.Join(keywordsDir, "desktop")
		if err := utils.WriteFile(keywordsPath, keywords.String(), 0644); err != nil {
			return utils.NewError("portage", "failed to write package.accept_keywords", err)
		}
	}

	return nil
}

// SetupPackageLicense sets up package.license.
func (m *Manager) SetupPackageLicense() error {
	licenseDir := filepath.Join(m.targetDir, "etc/portage/package.license")
	if err := utils.CreateDir(licenseDir, 0755); err != nil {
		return utils.NewError("portage", "failed to create package.license directory", err)
	}

	// Accept NVIDIA license if using NVIDIA drivers
	if m.config.Graphics.Driver == config.GPUNvidia || m.config.Graphics.Driver == config.GPUNvidiaOpen {
		content := "# NVIDIA drivers\nx11-drivers/nvidia-drivers NVIDIA-r2\n"
		licensePath := filepath.Join(licenseDir, "nvidia")
		if err := utils.WriteFile(licensePath, content, 0644); err != nil {
			return utils.NewError("portage", "failed to write package.license", err)
		}
	}

	return nil
}

// SetupReposConf sets up repos.conf.
func (m *Manager) SetupReposConf() error {
	utils.Info("Setting up repos.conf")

	reposDir := filepath.Join(m.targetDir, "etc/portage/repos.conf")
	if err := utils.CreateDir(reposDir, 0755); err != nil {
		return utils.NewError("portage", "failed to create repos.conf directory", err)
	}

	// Copy default gentoo.conf
	gentooConf := `[DEFAULT]
main-repo = gentoo

[gentoo]
location = /var/db/repos/gentoo
sync-type = rsync
sync-uri = rsync://rsync.gentoo.org/gentoo-portage
auto-sync = yes
sync-rsync-verify-jobs = 1
sync-rsync-verify-metamanifest = yes
sync-rsync-verify-max-age = 24
sync-openpgp-key-path = /usr/share/openpgp-keys/gentoo-release.asc
sync-openpgp-keyserver = hkps://keys.gentoo.org
sync-openpgp-key-refresh-retry-count = 40
sync-openpgp-key-refresh-retry-overall-timeout = 1200
sync-openpgp-key-refresh-retry-delay-exp-base = 2
sync-openpgp-key-refresh-retry-delay-max = 60
sync-openpgp-key-refresh-retry-delay-mult = 4
sync-webrsync-verify-signature = yes
`
	gentooConfPath := filepath.Join(reposDir, "gentoo.conf")
	if err := utils.WriteFile(gentooConfPath, gentooConf, 0644); err != nil {
		return utils.NewError("portage", "failed to write gentoo.conf", err)
	}

	return nil
}

// SelectProfile selects a Gentoo profile.
func (m *Manager) SelectProfile() error {
	profile := m.config.Portage.Profile
	if profile == "" {
		// Determine profile based on init system and desktop
		base := "default/linux/amd64/23.0"

		if m.config.Desktop.Type != config.DesktopNone {
			base += "/desktop"
		}

		switch m.config.Desktop.Type {
		case config.DesktopGNOME:
			base += "/gnome"
		case config.DesktopKDE:
			base += "/plasma"
		}

		if m.config.InitSystem == config.InitSystemd {
			base += "/systemd"
		}

		profile = base
	}

	utils.Info("Selecting profile: %s", profile)

	result := utils.RunInChroot(m.targetDir, "eselect", "profile", "set", profile)
	if result.Error != nil {
		// Try with full path
		result = utils.RunInChroot(m.targetDir, "eselect", "profile", "set",
			"/var/db/repos/gentoo/profiles/"+profile)
		if result.Error != nil {
			return utils.NewError("portage", "failed to select profile", result.Error)
		}
	}

	return nil
}

// SyncPortage syncs the Portage tree.
func (m *Manager) SyncPortage() error {
	utils.Info("Syncing Portage tree")

	// Use emerge-webrsync for initial sync
	result := utils.RunInChroot(m.targetDir, "emerge-webrsync")
	if result.Error != nil {
		return utils.NewError("portage", "failed to sync portage", result.Error)
	}

	return nil
}

// UpdateWorld updates @world set.
func (m *Manager) UpdateWorld(progress func(line string)) error {
	utils.Info("Updating @world")

	args := []string{m.targetDir, "emerge", "--update", "--deep", "--newuse", "@world"}

	if progress != nil {
		return utils.RunCommandWithOutput(progress, "chroot", args...)
	}

	result := utils.RunCommand("chroot", args...)
	if result.Error != nil {
		return utils.NewError("portage", "failed to update @world", result.Error)
	}

	return nil
}

// Setup performs complete Portage configuration.
func (m *Manager) Setup() error {
	// Generate make.conf
	if err := m.GenerateMakeConf(); err != nil {
		return err
	}

	// Setup repos.conf
	if err := m.SetupReposConf(); err != nil {
		return err
	}

	// Setup package.use
	if err := m.SetupPackageUse(); err != nil {
		return err
	}

	// Setup package.accept_keywords
	if err := m.SetupPackageAcceptKeywords(); err != nil {
		return err
	}

	// Setup package.license
	if err := m.SetupPackageLicense(); err != nil {
		return err
	}

	return nil
}

// CFlagsPresets returns available CFLAGS presets with descriptions.
func CFlagsPresets() map[config.CFlagsPreset]string {
	return map[config.CFlagsPreset]string{
		config.CFlagsSafe:       "Safe (-march=x86-64 -O2 -pipe) - Maximum compatibility",
		config.CFlagsOptimized:  "Optimized (-march=native -O2 -pipe) - Native CPU optimizations",
		config.CFlagsAggressive: "Aggressive (-march=native -O3 -pipe -flto=auto) - Maximum performance with LTO",
		config.CFlagsCustom:     "Custom - Specify your own CFLAGS",
	}
}
