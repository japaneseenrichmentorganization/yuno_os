// Package users handles user account management.
package users

import (
	"fmt"
	"path/filepath"
	"strings"

	"github.com/japaneseenrichmentorganization/yuno_os/pkg/config"
	"github.com/japaneseenrichmentorganization/yuno_os/pkg/utils"
)

// Manager handles user account operations.
type Manager struct {
	config    *config.InstallConfig
	targetDir string
}

// NewManager creates a new user manager.
func NewManager(cfg *config.InstallConfig, targetDir string) *Manager {
	return &Manager{
		config:    cfg,
		targetDir: targetDir,
	}
}

// SetRootPassword sets the root password.
func (m *Manager) SetRootPassword(password string) error {
	utils.Info("Setting root password")

	// Use chpasswd to set the password
	cmd := fmt.Sprintf("echo 'root:%s' | chpasswd", password)
	result := utils.RunInChroot(m.targetDir, "sh", "-c", cmd)
	if result.Error != nil {
		return utils.NewError("users", "failed to set root password", result.Error)
	}

	return nil
}

// CreateUser creates a new user account.
func (m *Manager) CreateUser(user config.UserConfig) error {
	utils.Info("Creating user: %s", user.Username)

	// Build useradd command
	args := []string{"-m"} // Create home directory

	// Add full name if provided
	if user.FullName != "" {
		args = append(args, "-c", user.FullName)
	}

	// Set shell
	shell := user.Shell
	if shell == "" {
		shell = "/bin/bash"
	}
	args = append(args, "-s", shell)

	// Add to groups
	groups := user.Groups
	if len(groups) == 0 {
		groups = defaultGroups()
	}
	args = append(args, "-G", strings.Join(groups, ","))

	// Add username
	args = append(args, user.Username)

	// Create user
	result := utils.RunInChroot(m.targetDir, "useradd", args...)
	if result.Error != nil {
		return utils.NewError("users", fmt.Sprintf("failed to create user %s", user.Username), result.Error)
	}

	// Set password
	if user.Password != "" {
		cmd := fmt.Sprintf("echo '%s:%s' | chpasswd", user.Username, user.Password)
		result = utils.RunInChroot(m.targetDir, "sh", "-c", cmd)
		if result.Error != nil {
			return utils.NewError("users", fmt.Sprintf("failed to set password for %s", user.Username), result.Error)
		}
	}

	// Configure sudo/doas
	if user.Sudo {
		if user.UseDoas {
			if err := m.configureDoas(user.Username); err != nil {
				return err
			}
		} else {
			if err := m.configureSudo(user.Username); err != nil {
				return err
			}
		}
	}

	return nil
}

// defaultGroups returns the default groups for a new user.
func defaultGroups() []string {
	return []string{
		"users",
		"wheel",
		"audio",
		"video",
		"input",
		"plugdev",
		"usb",
	}
}

// configureSudo configures sudo access for a user.
func (m *Manager) configureSudo(username string) error {
	utils.Info("Configuring sudo for %s", username)

	// Install sudo if not present
	sudoPath := filepath.Join(m.targetDir, "usr/bin/sudo")
	if !utils.FileExists(sudoPath) {
		result := utils.RunInChroot(m.targetDir, "emerge", "--ask=n", "app-admin/sudo")
		if result.Error != nil {
			return utils.NewError("users", "failed to install sudo", result.Error)
		}
	}

	// Configure sudoers
	sudoersDir := filepath.Join(m.targetDir, "etc/sudoers.d")
	if err := utils.CreateDir(sudoersDir, 0750); err != nil {
		return err
	}

	// Enable wheel group in sudoers
	sudoersContent := `# Allow members of wheel group to execute any command
%wheel ALL=(ALL:ALL) ALL

# Allow wheel members to use sudo without password (optional, commented)
# %wheel ALL=(ALL:ALL) NOPASSWD: ALL
`
	sudoersPath := filepath.Join(sudoersDir, "wheel")
	if err := utils.WriteFile(sudoersPath, sudoersContent, 0440); err != nil {
		return utils.NewError("users", "failed to write sudoers config", err)
	}

	return nil
}

// configureDoas configures doas access for a user.
func (m *Manager) configureDoas(username string) error {
	utils.Info("Configuring doas for %s", username)

	// Install doas
	result := utils.RunInChroot(m.targetDir, "emerge", "--ask=n", "app-admin/doas")
	if result.Error != nil {
		return utils.NewError("users", "failed to install doas", result.Error)
	}

	// Configure doas.conf
	doasContent := fmt.Sprintf(`# doas configuration - Generated by Yuno OS installer

# Allow wheel group members to run commands as root
permit persist :wheel

# Allow specific user
permit persist %s as root
`, username)

	doasPath := filepath.Join(m.targetDir, "etc/doas.conf")
	if err := utils.WriteFile(doasPath, doasContent, 0400); err != nil {
		return utils.NewError("users", "failed to write doas.conf", err)
	}

	return nil
}

// CreateUsers creates all configured users.
func (m *Manager) CreateUsers() error {
	// Set root password
	if m.config.RootPassword != "" {
		if err := m.SetRootPassword(m.config.RootPassword); err != nil {
			return err
		}
	}

	// Create each user
	for _, user := range m.config.Users {
		if err := m.CreateUser(user); err != nil {
			return err
		}
	}

	return nil
}

// SetupSkel sets up the skeleton directory for new users.
func (m *Manager) SetupSkel() error {
	utils.Info("Setting up user skeleton")

	skelDir := filepath.Join(m.targetDir, "etc/skel")

	// Create basic directories
	dirs := []string{
		".config",
		".local/bin",
		".local/share",
		"Documents",
		"Downloads",
		"Pictures",
		"Music",
		"Videos",
	}

	for _, dir := range dirs {
		path := filepath.Join(skelDir, dir)
		if err := utils.CreateDir(path, 0755); err != nil {
			return utils.NewError("users", fmt.Sprintf("failed to create skel/%s", dir), err)
		}
	}

	// Create basic .bashrc
	bashrc := `# ~/.bashrc

# If not running interactively, don't do anything
[[ $- != *i* ]] && return

# Aliases
alias ls='ls --color=auto'
alias ll='ls -la'
alias grep='grep --color=auto'
alias cp='cp -i'
alias mv='mv -i'
alias rm='rm -i'

# History
HISTSIZE=10000
HISTFILESIZE=20000
HISTCONTROL=ignoreboth

# Prompt
PS1='\[\e[1;32m\]\u@\h\[\e[0m\]:\[\e[1;34m\]\w\[\e[0m\]\$ '

# Environment
export EDITOR=nano
export VISUAL=$EDITOR

# Load local binaries
export PATH="$HOME/.local/bin:$PATH"
`
	bashrcPath := filepath.Join(skelDir, ".bashrc")
	if err := utils.WriteFile(bashrcPath, bashrc, 0644); err != nil {
		return utils.NewError("users", "failed to write .bashrc", err)
	}

	// Create .bash_profile
	bashProfile := `# ~/.bash_profile

# Source .bashrc if it exists
[[ -f ~/.bashrc ]] && . ~/.bashrc
`
	bashProfilePath := filepath.Join(skelDir, ".bash_profile")
	if err := utils.WriteFile(bashProfilePath, bashProfile, 0644); err != nil {
		return utils.NewError("users", "failed to write .bash_profile", err)
	}

	// Copy default avatar to user's face icon location
	avatarSrc := "/usr/share/yuno-os/avatars/default-avatar.jpg"
	if utils.FileExists(avatarSrc) {
		facePath := filepath.Join(skelDir, ".face")
		if err := utils.CopyFile(avatarSrc, facePath); err != nil {
			utils.Warn("Failed to copy default avatar: %v", err)
		}
		// Also copy to .face.icon for compatibility
		faceIconPath := filepath.Join(skelDir, ".face.icon")
		if err := utils.CopyFile(avatarSrc, faceIconPath); err != nil {
			utils.Warn("Failed to copy default avatar icon: %v", err)
		}
	}

	return nil
}

// ConfigureAutologin sets up automatic login for a user.
func (m *Manager) ConfigureAutologin(username string, tty int) error {
	utils.Info("Configuring autologin for %s on tty%d", username, tty)

	if m.config.InitSystem == config.InitSystemd {
		return m.configureSystemdAutologin(username, tty)
	}
	return m.configureOpenRCAutologin(username, tty)
}

// configureSystemdAutologin sets up autologin for systemd.
func (m *Manager) configureSystemdAutologin(username string, tty int) error {
	overrideDir := fmt.Sprintf("/etc/systemd/system/getty@tty%d.service.d", tty)
	fullDir := filepath.Join(m.targetDir, overrideDir)

	if err := utils.CreateDir(fullDir, 0755); err != nil {
		return err
	}

	content := fmt.Sprintf(`[Service]
ExecStart=
ExecStart=-/sbin/agetty --autologin %s --noclear %%I $TERM
`, username)

	overridePath := filepath.Join(fullDir, "autologin.conf")
	return utils.WriteFile(overridePath, content, 0644)
}

// configureOpenRCAutologin sets up autologin for OpenRC.
func (m *Manager) configureOpenRCAutologin(username string, tty int) error {
	// Modify /etc/inittab for agetty autologin
	inittabPath := filepath.Join(m.targetDir, "etc/inittab")

	content, err := utils.ReadFile(inittabPath)
	if err != nil {
		return utils.NewError("users", "failed to read inittab", err)
	}

	// Find and modify the tty line
	oldLine := fmt.Sprintf("c%d:12345:respawn:/sbin/agetty 38400 tty%d linux", tty, tty)
	newLine := fmt.Sprintf("c%d:12345:respawn:/sbin/agetty --autologin %s 38400 tty%d linux", tty, username, tty)

	content = strings.Replace(content, oldLine, newLine, 1)

	return utils.WriteFile(inittabPath, content, 0644)
}

// LockRootAccount locks the root account (disable direct login).
func (m *Manager) LockRootAccount() error {
	utils.Info("Locking root account")

	result := utils.RunInChroot(m.targetDir, "passwd", "-l", "root")
	if result.Error != nil {
		return utils.NewError("users", "failed to lock root account", result.Error)
	}

	return nil
}

// SetupGroups creates any necessary groups.
func (m *Manager) SetupGroups() error {
	groups := []string{"plugdev", "usb", "input"}

	for _, group := range groups {
		// Check if group exists
		result := utils.RunInChroot(m.targetDir, "getent", "group", group)
		if result.ExitCode != 0 {
			// Create group
			result = utils.RunInChroot(m.targetDir, "groupadd", group)
			if result.Error != nil {
				utils.Warn("Failed to create group %s: %v", group, result.Error)
			}
		}
	}

	return nil
}

// Setup performs complete user setup.
func (m *Manager) Setup() error {
	// Setup groups
	if err := m.SetupGroups(); err != nil {
		return err
	}

	// Setup skeleton
	if err := m.SetupSkel(); err != nil {
		return err
	}

	// Create users
	if err := m.CreateUsers(); err != nil {
		return err
	}

	return nil
}

// DefaultUserConfig returns a default user configuration.
func DefaultUserConfig(username string) config.UserConfig {
	return config.UserConfig{
		Username: username,
		Shell:    "/bin/bash",
		Groups:   defaultGroups(),
		Sudo:     true,
		UseDoas:  false,
	}
}
