// Package bootloader handles bootloader installation and Secure Boot.
package bootloader

import (
	"fmt"
	"path/filepath"
	"strings"

	"github.com/japaneseenrichmentorganization/yuno_os/pkg/config"
	"github.com/japaneseenrichmentorganization/yuno_os/pkg/utils"
)

// Manager handles bootloader operations.
type Manager struct {
	config    *config.InstallConfig
	targetDir string
}

// NewManager creates a new bootloader manager.
func NewManager(cfg *config.InstallConfig, targetDir string) *Manager {
	return &Manager{
		config:    cfg,
		targetDir: targetDir,
	}
}

// Install installs the bootloader based on configuration.
func (m *Manager) Install() error {
	bootloader := m.config.Bootloader.Type

	utils.Info("Installing bootloader: %s", bootloader)

	switch bootloader {
	case config.BootGRUB:
		return m.installGRUB()
	case config.BootSystemdBoot:
		return m.installSystemdBoot()
	default:
		return m.installGRUB()
	}
}

// installGRUB installs GRUB bootloader.
func (m *Manager) installGRUB() error {
	// Install grub package
	result := utils.RunInChroot(m.targetDir, "emerge", "--ask=n", "sys-boot/grub")
	if result.Error != nil {
		return utils.NewError("bootloader", "failed to install grub", result.Error)
	}

	// Install efibootmgr for UEFI
	if utils.IsUEFI() {
		result = utils.RunInChroot(m.targetDir, "emerge", "--ask=n", "sys-boot/efibootmgr")
		if result.Error != nil {
			utils.Warn("Failed to install efibootmgr: %v", result.Error)
		}
	}

	// Configure GRUB
	if err := m.configureGRUB(); err != nil {
		return err
	}

	// Install GRUB
	if utils.IsUEFI() {
		return m.installGRUBUEFI()
	}
	return m.installGRUBBIOS()
}

// configureGRUB generates GRUB configuration.
func (m *Manager) configureGRUB() error {
	utils.Info("Configuring GRUB")

	grubDir := filepath.Join(m.targetDir, "etc/default")
	if err := utils.CreateDir(grubDir, 0755); err != nil {
		return utils.NewError("bootloader", "failed to create grub config dir", err)
	}

	// Build GRUB_CMDLINE_LINUX
	var cmdline []string

	// Add encryption support if enabled
	if m.config.Encryption.Type != config.EncryptNone {
		// Find root device UUID
		rootUUID := m.getRootUUID()
		if rootUUID != "" {
			cmdline = append(cmdline, fmt.Sprintf("rd.luks.uuid=%s", rootUUID))
		}
		cmdline = append(cmdline, "rd.luks=1")
	}

	// Add init system specific options
	if m.config.InitSystem == config.InitSystemd {
		cmdline = append(cmdline, "init=/lib/systemd/systemd")
	}

	// Graphics options
	switch m.config.Graphics.Driver {
	case config.GPUNvidia, config.GPUNvidiaOpen:
		cmdline = append(cmdline, "nvidia-drm.modeset=1")
	}

	content := fmt.Sprintf(`# GRUB configuration - Generated by Yuno OS installer

GRUB_DEFAULT=0
GRUB_TIMEOUT=5
GRUB_DISTRIBUTOR="Yuno OS"
GRUB_CMDLINE_LINUX="%s"
GRUB_CMDLINE_LINUX_DEFAULT="quiet"

# Graphics
GRUB_GFXMODE=auto
GRUB_GFXPAYLOAD_LINUX=keep

# Security
GRUB_DISABLE_RECOVERY=true
`, strings.Join(cmdline, " "))

	confPath := filepath.Join(grubDir, "grub")
	if err := utils.WriteFile(confPath, content, 0644); err != nil {
		return utils.NewError("bootloader", "failed to write grub config", err)
	}

	return nil
}

// installGRUBUEFI installs GRUB for UEFI systems.
func (m *Manager) installGRUBUEFI() error {
	utils.Info("Installing GRUB for UEFI")

	// Install GRUB to EFI system partition
	result := utils.RunInChroot(m.targetDir, "grub-install",
		"--target=x86_64-efi",
		"--efi-directory=/boot",
		"--bootloader-id=YunoOS",
		"--recheck")

	if result.Error != nil {
		return utils.NewError("bootloader", "grub-install failed", result.Error)
	}

	// Generate GRUB configuration
	return m.generateGRUBConfig()
}

// installGRUBBIOS installs GRUB for BIOS systems.
func (m *Manager) installGRUBBIOS() error {
	utils.Info("Installing GRUB for BIOS")

	device := m.config.Disk.Device

	result := utils.RunInChroot(m.targetDir, "grub-install",
		"--target=i386-pc",
		"--recheck",
		device)

	if result.Error != nil {
		return utils.NewError("bootloader", "grub-install failed", result.Error)
	}

	return m.generateGRUBConfig()
}

// generateGRUBConfig generates grub.cfg.
func (m *Manager) generateGRUBConfig() error {
	utils.Info("Generating GRUB configuration")

	result := utils.RunInChroot(m.targetDir, "grub-mkconfig", "-o", "/boot/grub/grub.cfg")
	if result.Error != nil {
		return utils.NewError("bootloader", "grub-mkconfig failed", result.Error)
	}

	return nil
}

// installSystemdBoot installs systemd-boot (UEFI only).
func (m *Manager) installSystemdBoot() error {
	if !utils.IsUEFI() {
		utils.Warn("systemd-boot requires UEFI, falling back to GRUB")
		return m.installGRUB()
	}

	utils.Info("Installing systemd-boot")

	// Install systemd-boot
	result := utils.RunInChroot(m.targetDir, "bootctl", "install")
	if result.Error != nil {
		return utils.NewError("bootloader", "bootctl install failed", result.Error)
	}

	// Configure loader
	if err := m.configureSystemdBoot(); err != nil {
		return err
	}

	// Create boot entry
	return m.createSystemdBootEntry()
}

// configureSystemdBoot configures systemd-boot loader.
func (m *Manager) configureSystemdBoot() error {
	loaderDir := filepath.Join(m.targetDir, "boot/loader")
	if err := utils.CreateDir(loaderDir, 0755); err != nil {
		return err
	}

	content := `default yuno.conf
timeout 5
console-mode max
editor no
`

	confPath := filepath.Join(loaderDir, "loader.conf")
	return utils.WriteFile(confPath, content, 0644)
}

// createSystemdBootEntry creates a boot entry for systemd-boot.
func (m *Manager) createSystemdBootEntry() error {
	entriesDir := filepath.Join(m.targetDir, "boot/loader/entries")
	if err := utils.CreateDir(entriesDir, 0755); err != nil {
		return err
	}

	// Get kernel and initramfs
	kernelVersion := m.getKernelVersion()
	rootUUID := m.getRootUUID()

	var options []string
	options = append(options, fmt.Sprintf("root=UUID=%s", rootUUID))
	options = append(options, "rw")

	if m.config.Encryption.Type != config.EncryptNone {
		luksUUID := m.getLUKSUUID()
		if luksUUID != "" {
			options = append(options, fmt.Sprintf("rd.luks.uuid=%s", luksUUID))
		}
	}

	if m.config.Graphics.Driver == config.GPUNvidia || m.config.Graphics.Driver == config.GPUNvidiaOpen {
		options = append(options, "nvidia-drm.modeset=1")
	}

	content := fmt.Sprintf(`title   Yuno OS
linux   /vmlinuz-%s
initrd  /initramfs-%s.img
options %s
`, kernelVersion, kernelVersion, strings.Join(options, " "))

	entryPath := filepath.Join(entriesDir, "yuno.conf")
	return utils.WriteFile(entryPath, content, 0644)
}

// SetupSecureBoot configures Secure Boot.
func (m *Manager) SetupSecureBoot() error {
	if !m.config.Bootloader.SecureBoot.Enabled {
		return nil
	}

	utils.Info("Setting up Secure Boot")

	// Install required packages
	result := utils.RunInChroot(m.targetDir, "emerge", "--ask=n",
		"app-crypt/sbsigntools", "app-crypt/efitools")
	if result.Error != nil {
		return utils.NewError("bootloader", "failed to install secure boot tools", result.Error)
	}

	keyDir := m.config.Bootloader.SecureBoot.KeyDir
	if keyDir == "" {
		keyDir = "/etc/secureboot"
	}

	// Generate keys if using custom keys
	if m.config.Bootloader.SecureBoot.KeyType == "custom" {
		if err := m.generateSecureBootKeys(keyDir); err != nil {
			return err
		}
	}

	// Sign the bootloader and kernel
	return m.signBootFiles(keyDir)
}

// generateSecureBootKeys generates MOK keys for Secure Boot.
func (m *Manager) generateSecureBootKeys(keyDir string) error {
	utils.Info("Generating Secure Boot keys")

	fullKeyDir := filepath.Join(m.targetDir, keyDir)
	if err := utils.CreateDir(fullKeyDir, 0700); err != nil {
		return err
	}

	// Generate MOK key pair
	// Create openssl config
	opensslConf := `[ req ]
default_bits         = 4096
encrypt_key          = no
string_mask          = utf8only
utf8                 = yes
prompt               = no
distinguished_name   = dn
x509_extensions      = v3_req

[ dn ]
CN = Yuno OS Secure Boot Signing Key

[ v3_req ]
basicConstraints     = CA:FALSE
keyUsage             = digitalSignature
extendedKeyUsage     = codeSigning
subjectKeyIdentifier = hash
`
	confPath := filepath.Join(fullKeyDir, "openssl.cnf")
	if err := utils.WriteFile(confPath, opensslConf, 0644); err != nil {
		return err
	}

	// Generate key
	result := utils.RunInChroot(m.targetDir, "openssl", "req",
		"-new", "-x509",
		"-newkey", "rsa:4096",
		"-keyout", filepath.Join(keyDir, "MOK.key"),
		"-out", filepath.Join(keyDir, "MOK.crt"),
		"-days", "3650",
		"-sha256",
		"-nodes",
		"-config", filepath.Join(keyDir, "openssl.cnf"))

	if result.Error != nil {
		return utils.NewError("bootloader", "failed to generate MOK key", result.Error)
	}

	// Convert to DER format for enrollment
	result = utils.RunInChroot(m.targetDir, "openssl", "x509",
		"-in", filepath.Join(keyDir, "MOK.crt"),
		"-out", filepath.Join(keyDir, "MOK.der"),
		"-outform", "DER")

	if result.Error != nil {
		return utils.NewError("bootloader", "failed to convert MOK to DER", result.Error)
	}

	return nil
}

// signBootFiles signs the bootloader and kernel.
func (m *Manager) signBootFiles(keyDir string) error {
	utils.Info("Signing boot files")

	keyPath := filepath.Join(keyDir, "MOK.key")
	certPath := filepath.Join(keyDir, "MOK.crt")

	// Find files to sign
	bootDir := filepath.Join(m.targetDir, "boot")

	// Sign kernel
	result := utils.RunCommand("find", bootDir, "-name", "vmlinuz-*")
	if result.Error == nil {
		for _, kernel := range strings.Split(result.Stdout, "\n") {
			if kernel == "" {
				continue
			}
			m.signFile(kernel, keyPath, certPath)
		}
	}

	// Sign GRUB EFI if exists
	grubEFI := filepath.Join(bootDir, "EFI/YunoOS/grubx64.efi")
	if utils.FileExists(grubEFI) {
		m.signFile(grubEFI, keyPath, certPath)
	}

	// Enroll keys if requested
	if m.config.Bootloader.SecureBoot.EnrollKeys {
		return m.enrollMOK(keyDir)
	}

	return nil
}

// signFile signs a single file with sbsign.
func (m *Manager) signFile(file, keyPath, certPath string) error {
	utils.Debug("Signing %s", file)

	signedFile := file + ".signed"

	result := utils.RunInChroot(m.targetDir, "sbsign",
		"--key", keyPath,
		"--cert", certPath,
		"--output", signedFile,
		file)

	if result.Error != nil {
		return utils.NewError("bootloader", fmt.Sprintf("failed to sign %s", file), result.Error)
	}

	// Replace original with signed version
	return utils.RunCommand("mv", signedFile, file).Error
}

// enrollMOK prepares MOK for enrollment.
func (m *Manager) enrollMOK(keyDir string) error {
	utils.Info("Preparing MOK enrollment")

	mokDer := filepath.Join(m.targetDir, keyDir, "MOK.der")

	// Import MOK for enrollment on next boot
	result := utils.RunInChroot(m.targetDir, "mokutil", "--import", mokDer)
	if result.Error != nil {
		utils.Warn("MOK enrollment will need to be done manually")
		utils.Info("Run: mokutil --import %s/MOK.der", keyDir)
	}

	return nil
}

// Helper functions

// getRootUUID returns the UUID of the root partition.
func (m *Manager) getRootUUID() string {
	// Try to find root partition
	for _, part := range m.config.Partitions {
		if part.MountPoint == "/" {
			device := m.getPartitionDevice(part.Label)
			result := utils.RunCommand("blkid", "-s", "UUID", "-o", "value", device)
			if result.Error == nil {
				return strings.TrimSpace(result.Stdout)
			}
		}
	}
	return ""
}

// getLUKSUUID returns the UUID of the LUKS container.
func (m *Manager) getLUKSUUID() string {
	for _, part := range m.config.Partitions {
		if part.Encrypt && part.MountPoint == "/" {
			device := m.getPartitionDevice(part.Label)
			result := utils.RunCommand("cryptsetup", "luksUUID", device)
			if result.Error == nil {
				return strings.TrimSpace(result.Stdout)
			}
		}
	}
	return ""
}

// getKernelVersion returns the installed kernel version.
func (m *Manager) getKernelVersion() string {
	bootDir := filepath.Join(m.targetDir, "boot")
	result := utils.RunCommand("ls", bootDir)
	if result.Error != nil {
		return "linux"
	}

	for _, file := range strings.Split(result.Stdout, "\n") {
		if strings.HasPrefix(file, "vmlinuz-") {
			return strings.TrimPrefix(file, "vmlinuz-")
		}
	}
	return "linux"
}

// getPartitionDevice returns the device path for a partition label.
func (m *Manager) getPartitionDevice(label string) string {
	device := m.config.Disk.Device
	for i, part := range m.config.Partitions {
		if part.Label == label {
			if strings.Contains(device, "nvme") || strings.Contains(device, "mmcblk") {
				return fmt.Sprintf("%sp%d", device, i+1)
			}
			return fmt.Sprintf("%s%d", device, i+1)
		}
	}
	return ""
}

// Setup performs complete bootloader setup.
func (m *Manager) Setup() error {
	// Install bootloader
	if err := m.Install(); err != nil {
		return err
	}

	// Setup Secure Boot if enabled
	if m.config.Bootloader.SecureBoot.Enabled {
		if err := m.SetupSecureBoot(); err != nil {
			return err
		}
	}

	return nil
}

// BootloaderDescriptions returns descriptions for bootloader types.
func BootloaderDescriptions() map[config.BootloaderType]string {
	return map[config.BootloaderType]string{
		config.BootGRUB:        "GRUB - Universal bootloader (UEFI + BIOS)",
		config.BootSystemdBoot: "systemd-boot - Simple UEFI boot manager",
	}
}
